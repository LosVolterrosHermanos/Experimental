import jax
import jax.numpy as jnp
import jax.random as random
import scipy as sp

from theory import theory_limitloss, theory_rho_weights

########################################################
# Power-law random features regression class
# Theory tools are callable from the class
# Instantiate the class for a sample of the PLRF
########################################################

class PowerLawRF:
  """
  A class that generates power-law random features regression problems.

  This class creates synthetic regression problems with power-law decaying eigenvalues 
  and target coefficients. The features are generated by first sampling random Gaussian 
  features and then scaling them according to a power law.

  Attributes:
      alpha (float): Power law exponent for eigenvalue decay
      beta (float): Power law exponent for target coefficient decay  
      W (ndarray): Random features matrix of shape (v, d)
      v (int): Hidden dimensionality
      d (int): Embedded dimensionality
      x_grid (ndarray): Grid of indices from 1 to v, shape (1,v)
      population_eigenvalues (ndarray): Power-law decaying eigenvalues
      b (ndarray): Power-law decaying target coefficients
      population_trace (float): Sum of population eigenvalues
      checkW (ndarray): Scaled random features matrix
      checkb (ndarray): Scaled target coefficients
  """

  def __init__(self, alpha, beta, W):
      self.alpha = alpha
      self.beta = beta
      self.W = W
      self.v = self.W.shape[0]
      self.d = self.W.shape[1]
      self.x_grid=jnp.arange(1, self.v+1).reshape(1,self.v)
      self.population_eigenvalues = self.x_grid**(-self.alpha)
      self.b = self.x_grid.transpose()**(-beta)
      self.population_trace = jnp.sum(self.population_eigenvalues)
      self.checkW = W * self.population_eigenvalues.T
      self.checkb = self.x_grid.transpose()**(-alpha-beta)
      
  @classmethod
  def initialize_random(cls, alpha, beta, v, d, key):
      """
      Creates a new power_law_RF instance with randomly initialized features.

      Args:
          alpha (float): Power law exponent for eigenvalue decay
          beta (float): Power law exponent for target coefficient decay
          v (int): Hidden dimensionality
          d (int): Embedded dimensionality
          key (PRNGKey): JAX random number generator key

      Returns:
          power_law_RF: A new instance with randomly sampled features matrix W
                        scaled to have variance 1/d
      """
      # Sample random features matrix with variance 1/d
      W = random.normal(key, (v, d)) / jnp.sqrt(d)
      return cls(alpha=alpha, beta=beta, W=W)
  
  def get_population_risk(self, w):
      """
      Calculates the population risk for given weights.
      
      The population risk is the expected squared error over the data distribution.
      For power-law random features regression, this can be computed analytically
      without sampling data.
      
      Args:
          w (ndarray): Weight vector of shape (d,)
      
      Returns:
          float: Population risk value
      """
      # Project weights onto random features
      proj = jnp.matmul(self.checkW, w)
      
      # Calculate population risk using eigenvalues and target coefficients
      risk = jnp.sum((proj - self.checkb)**2)
      return risk / 2
  

  def get_data(self, key, batch):
      """
      Generates a batch of synthetic data points.
      
      Args:
          key (PRNGKey): JAX random number generator key
          batch (int): Number of data points to generate
          
      Returns:
          tuple: (X, y) where:
              X (ndarray): Input features of shape (batch, d)
              y (ndarray): Target values of shape (batch, 1)
      """
      # Generate random features
      x = random.normal(key, (batch, self.v))
      
      return jnp.matmul(x, self.checkW), jnp.matmul(x, self.checkb)
  
  def get_theory_limitloss(self):
      """Returns the theoretical limit of the loss (residual risk) for the current model parameters.
      
      Calculates the theoretical prediction for the residual risk level (risk at infinite time)
      using the model's alpha, beta, v (number of random features), and d (input dimension) parameters.
      
      Returns:
          float: Theoretical prediction for the residual risk level
      """
      return theory_limitloss(self.alpha,self.beta,self.v,self.d)

  def get_theory_rho_weights(self,num_splits, a, b, xs_per_split = 10000):
  """Generate the initial rho_j's deterministically.
  This performs many small contour integrals each surrounding the real eigenvalues
  where the vector a contains the values for the lower (left) edges of the
  contours and the vector b contains the values of the upper (right) edges of the
  contours.
  """
  v, d, alpha, beta = self.v, self.d, self.alpha, self.beta
  return theory_rho_weights(v, d, alpha, beta, num_splits, a, b, xs_per_split)
